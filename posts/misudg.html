<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Maximum Independent Set on Unit Disk Graph</title>
  <meta name="author" content="Elijah Tarr" />
  <meta name="description" content="oriont's posts" />
  <meta name="keywords" content="coding,programming" />

  <link rel="stylesheet" href="/assets/css/style.css" />
  <script>
    if (
      localStorage.getItem("color-theme") === "dark" ||
      (!("color-theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches)
    ) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  </script>

  
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X"
    crossorigin="anonymous"
  />

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"
  ></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"
    crossorigin="anonymous"
    onload="renderMathInElement(document.body)"
  ></script>
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-YW05BX01LE"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-YW05BX01LE");
  </script>
</head>


  <body class="dark:bg-zinc-800">
    <div class="container w-full md:max-w-3xl mx-auto pt-2 md:pt-10">
      <div
        class="w-full px-4 md:px-6 text-xl text-gray-800 leading-normal"
        style="font-family: Georgia, serif"
      >
        
        <div class="flex pt-2">
          <p class="my-auto p-0"><a href="/" class="link pr-5">Home</a></p>
          <button
  id="theme-toggle"
  type="button"
  class="text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 rounded-lg text-sm p-2.5"
>
  <svg
    id="theme-toggle-light-icon"
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6 hidden"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z"
    />
  </svg>

  <svg
    id="theme-toggle-dark-icon"
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6 hidden"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z"
    />
  </svg>
</button>

<script>
  var themeToggleDarkIcon = document.getElementById("theme-toggle-dark-icon");
  var themeToggleLightIcon = document.getElementById("theme-toggle-light-icon");

  // Change the icons inside the button based on previous settings
  if (
    localStorage.getItem("color-theme") === "dark" ||
    (!("color-theme" in localStorage) &&
      window.matchMedia("(prefers-color-scheme: dark)").matches)
  ) {
    themeToggleLightIcon.classList.remove("hidden");
  } else {
    themeToggleDarkIcon.classList.remove("hidden");
  }

  var themeToggleBtn = document.getElementById("theme-toggle");

  themeToggleBtn.addEventListener("click", function () {
    // toggle icons inside button
    themeToggleDarkIcon.classList.toggle("hidden");
    themeToggleLightIcon.classList.toggle("hidden");

    // if set via local storage previously
    if (localStorage.getItem("color-theme")) {
      if (localStorage.getItem("color-theme") === "light") {
        document.documentElement.classList.add("dark");
        localStorage.setItem("color-theme", "dark");
      } else {
        document.documentElement.classList.remove("dark");
        localStorage.setItem("color-theme", "light");
      }

      // if NOT set via local storage previously
    } else {
      if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark");
        localStorage.setItem("color-theme", "light");
      } else {
        document.documentElement.classList.add("dark");
        localStorage.setItem("color-theme", "dark");
      }
    }
  });
</script>

        </div>
         
        <h1 class="pt-3 md:pt-6 text-3xl md:text-4xl">Maximum Independent Set on Unit Disk Graph</h1>
         

        <div id="markdown"><p>In this post I’ll share a practice exercise I got from my CS 4540 class at Georgia Tech and my solution to it.</p>

<p><img src="/assets/images/misudg/misudg_ex.jpeg" alt="MISUDG" /></p>

<h2 id="the-problem">The Problem</h2>
<p>In the Maximum Independent Set on Unit Disk Graph (MISUDG) problem, we are given a set \(S\) of unit-
diameter disks in the plane. The goal is to find a maximum-cardinality subset \(S' \subset S\) of disks, such that no
two disks in \(S'\) overlap. (We say that disks that only touch on the boundary do not overlap). As with the
Maximum Independent Set problem, this problem is also NP-Complete.</p>
<ol>
  <li>Consider the following greedy algorithm: start with \(S' = \varnothing\) and process the disks in S one by one,
in any order. For each such disk \(C\), if \(S' \cup C\) is a feasible solution, then add C to S′. What is the approxi-
mation factor of this algorithm? (Give the best upper bound you can.)</li>
  <li>Let \(0 &lt; \epsilon &lt; 1\) be some constant. Assume that we are given a grid whose lines are spaced \(\dfrac{1}{\epsilon}\) units
apart. Assume further that no disk in the input set S intersects the grid lines. Give a polynomial time
algorithm for solving the problem exactly in this case.</li>
  <li>Derive and analyze a PTAS for the MISUDG problem. <strong>Hint:</strong> Consider a grid with random offset:
Take a grid of lines spaced \(\dfrac{1}{2}\) apart, such that the origin is at the intersection of a horizontal and vertical grid
line. Pick a shift/offset \(L\) uniformly at random from \([0, \dfrac{1}{2})\), and shift the grid vertically and horizontally by
an distance \(L\). (Equivalently, consider the grid of spacing \(\dfrac{1}{2}\) such that the point \((L, L)\) is at the intersection
of two grid lines.) What is the probability that a disk is intersected by a grid line?</li>
</ol>

<h2 id="observe">Observe</h2>

<p>We start out by noticing that for a disk \(x\), the maximum number of independent neighbors is 5.
This is because each neighbor must intersect \(x\), and the angle between the centers of neighbors must be greater than \(60^\circ\).
If \(\theta \leq 60\) then the neighbors would intersect eachother and wouldn’t be independent anymore, a contradiction.
Since there are \(360^\circ\) around \(x\), we have:</p>

\[360 = n (60 + \delta)\]

\[n &lt; 6\]

<p><img src="/assets/images/misudg/misudg_angle.jpeg" alt="Disk Angles" /></p>

<p>This means the <strong>maximum</strong> number of independent neighbors for <strong>any</strong> given disk is \(5\).</p>

<h2 id="solution-to-1">Solution to 1</h2>

<p>The greedy algorithm doesn’t choose disks in any particular order, so we choose the order it uses in the worst case scenario.
Notice for disk \(x\) with \(5\) independent neighbors, 2 maximal solutions would be either just disk \(x\), or all of the \(5\) independent neighbors.
(None of these neighbors intersect each other, so they would form an independent set.)</p>

<p>Let \(C^*\) be the largest independent set. 
For each disk \(d\), the worst possible case would be if instead of choosing \(d\), we chose its (up to) \(5\) independent neighbors.
Let \(C\) represent the greedy solution. 
So, we have \(|C| \leq 5 |C^*|\). 
This means greedy is a \(5\)-approximation of the optimal algorithm.</p>

<h3 id="remark">Remark</h3>

<p>Realistically, the actual approximation is a little better for larger input sets, since apart from this trivial case, not every disk in the optimal solution is surrounded by \(5\) independent disks. See the following picture for reference.</p>

<p><img src="/assets/images/misudg/misudg_stacked_disks.jpeg" alt="Stacked Disks" /></p>

<h2 id="solution-to-2">Solution to 2</h2>

<p>I thought this solution was pretty cool: we know independent set is NP-complete, so we can’t just convert to a graph and solve.
Instead, we do a crazy brute-force algorithm.</p>

<p>Consider a single grid square of size \(\dfrac{1}{\epsilon} \times \dfrac{1}{\epsilon}\).
We split up this grid further into squares of size \(\alpha \times \alpha\). 
Each smaller square we assign the set of disks whose centers are contained within that square. 
(As an edge case, if a center is on the boundary, we just assign it to one of the squares.)</p>

<p>As long as we choose \(\alpha\) such that we can’t fit 2 disks next to each other without them intersecting in an \(\alpha \times \alpha\) square, we know at most 1 disk contained from this square will be in the independent set. 
(Since if there were 2, then they must intersect eachother, and therefore it wouldn’t be an independent set anymore)
We can choose \(\alpha = \dfrac{1}{\sqrt 2} - \delta\) since the longest distance in a square of side length \(\alpha\) is the diagonal of length less than \(1\).
If there were a disk on opposite corners, they must intersect since the radii are \(0.5\) but the distance between centers is less than \(1\). 
(We can set \(\delta=0\) for the purposes of the rest of the problem)</p>

<p><img src="/assets/images/misudg/misudg_small_grid.jpeg" alt="Smaller Grid" /></p>

<p>The actual independent set will contain 0 or 1 disk from each square–we know this because disks can still intersect across the little square boundaries, meaning we choose a disk from one little square but not the other. 
From this we can make a polynomial-sized list of candidates: we get every combination of 0 or 1 disk from each smaller square.
At most, there are \(n=|S|\) disks per smaller square. (Because what if all disks were in one square)
There are \(\dfrac{\dfrac{1}{\epsilon}}{\alpha}\) smaller squares per side of a larger square, giving us \(\dfrac{1}{(\epsilon \alpha)^2}\) total smaller squares per larger square.
This means there are at most \(n^\dfrac{1}{(\epsilon \alpha)^2}\) candidates to look through.
(We just take the number of combinations of the max number of disks in smaller square)</p>

<p>As large of a polynomial this is, it is still a polynomial, and we can loop through each candidate to check if it as an independent set, and find the largest one among those which are.
This is a polynomial way of getting the independent set for one square–we know the max independent set will be the union of all the max independent sets of the grid squares. 
(Since no disk can intersect across larger squares, we don’t have to worry about trying each candidate!)
Thus we have a polynomial time algorithm to give us an exact answer!</p>

<h3 id="remark-1">Remark</h3>

<p>Theoretically, and perhaps impractically (although this entire solution is impractical) we could do away with the larger grid and solve the entire problem exactly using the smaller grid squares. This would result in a much larger polynomial than we already had, but would still work. 
Also, the big grid square probably won’t divide \(\alpha\) evenly. This is fine, as we only really care about being able to iterate over <strong>space</strong> (which is polynomial) rather than <strong>vertex combinations</strong> (which is exponential).</p>

<h2 id="solution-to-3">Solution to 3</h2>

<p>We make the bigger grid and shift it by \(L\). 
We remove each disk that intersects a bigger grid line, and run the algorithm outlined in part 2 on this new set, giving us an approximation of the independent set. 
For the approximation ratio, we consider which disks we remove (which disks intersect the grid line).</p>

<p><img src="/assets/images/misudg/misudg_bigger_smaller.jpeg" alt="Bigger/Smaller square" /></p>

<p>If disks are within \(\dfrac{1}{2}\) of the grid line for a given grid square, then it will be removed. 
Our approximation only uses the ones that aren’t within \(\dfrac{1}{2}\) of the grid lines, or those that are within a \(\dfrac{1}{\epsilon} - \dfrac{1}{2} - \dfrac{1}{2}\) square inside the square. 
If we assume the disks are in a random position in the square, the probability is the area of the inner square minus the area of the outer square, which is the following</p>

\[\dfrac{\left(\dfrac{1}{\epsilon}-1\right)^2}{\dfrac{1}{\epsilon^2}} = \dfrac{\dfrac{(1-\epsilon)^2}{\epsilon^2}}{\dfrac{1}{\epsilon^2}} = (1-\epsilon)^2\]

<p>We are allowed to assume the disks are in a random position (relative to the grid lines) since we shift the grid by a random offset \(L\).
If we didn’t shift it, an adaptive offline adversary would be able to “set” the inputs to only disks that intersect the grid line, for example, which would return an independent set of size 0. 
Obviously, this isn’t a very good approximation!</p>

<p>So, this algorithm is a \((1-\epsilon)^2\) polynomial time approximation scheme for MISUDG!</p>

<h3 id="the-end">The End</h3>

<p>Thanks for reading! If you spot any mistakes (which are likely, this is unedited and kinda unchecked) then please feel free to reach out to me or fix them yourself on github issues. Or, if you have any insights, be sure to let me know!</p>
</div>

        <footer class="text-slate-400 pt-10 pb-7">
          <a class="link" href="/">Home</a> -
          <a class="link" href="/about">About</a> -
          <a class="link" href="/resume">Resume</a> -
          <a class="link" href="/games">Games</a>
          <br />
          Copyright © 2023 - Elijah Tarr
        </footer>
      </div>
    </div>
  </body>
</html>
